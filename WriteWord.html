<!doctype html>
<html>
<head lang="en">
	<meta charset="utf-8">
	<title>First Blood of Canvas</title>
	<style>
		* {
			margin: 0;
			padding: 0;
		}
		
		#Canvas {
			display: block;
			position: relative;
			border: 1px solid #aaa;
			display: block;
			margin: 20px auto;
		}
		
		body {
			position: relative;
		}
		
		footer {
			display: block;
			width: 800px;
			height: 100px;
			margin: 0 auto;
		}
		
		button {
			display: block;
			margin: auto 0px;
			border: 1px solid red;
			background-color: #ccc;
			width: 80px;
			height: 40px;
		}
		
		button:hover {
			background-color: #ff6f6f;
		}
	</style>
	<script src="http://libs.baidu.com/jquery/1.10.2/jquery.js"></script>
</head>

<body>
	<canvas id='Canvas' width='600' height="250">Fuck IE NO Canvas!</canvas>
	<footer><button id="clear">CLEAR</button></footer>
</body>
<script>
	const canvasWidth = 800,
		canvasHeight = 800;
	var ctx, canvas;
	var PI = Math.PI;
	var isMouseDown = false;
	var lastLoc = {
			x: 0,
			y: 0
		},
		curLoc;
	var lastTime;
	var lastLineWidth = -1;
	$(document).ready(function() {
		canvas = $('Canvas')[0];
		ctx = canvas.getContext('2d');
		canvas.width = canvasWidth;
		canvas.height = canvasHeight;
		drawRice();
		//阻止默认行为
		canvas.onmousedown = function(e) {
			e.preventDefault();
			isMouseDown = true;
			lastLoc = windowToCanvas(e.clientX, e.clientY);
			lastTime = new Date().getTime();
		}
		canvas.onmouseup = function(e) {
			e.preventDefault();
			isMouseDown = false;
		}
		canvas.onmouseout = function(e) {
			e.preventDefault();
			isMouseDown = false;
		}
		canvas.onmousemove = function(e) {
			e.preventDefault();
			if (isMouseDown) {
				//calculate
				curLoc = windowToCanvas(e.clientX, e.clientY);
				var s = Distance(lastLoc, curLoc);
				var curTime = new Date().getTime();
				var lineWidth = calcLineWidth(curTime - lastTime, s);
				//draw
				ctx.beginPath();
				ctx.strokeStyle = 'black';
				ctx.lineWidth = lineWidth;
				ctx.lineCap = 'round';
				ctx.lineJoin = 'round';
				ctx.moveTo(lastLoc.x, lastLoc.y);
				ctx.lineTo(curLoc.x, curLoc.y);
				ctx.stroke();

				//update
				lastLoc = curLoc;
				lastTime = curTime;
			}
		}
		$('button').click(function() {
			$(this).fadeOut(50).fadeIn(50);
		})
		$('#clear').click(function() {
			//alert(Math.max.apply(null,Vlist)+","+Math.min.apply(null,Vlist));
			ctx.clearRect(0, 0, canvasWidth, canvasHeight);
			drawRice();
		})
	});
	//var Vlist = new Array();
	function calcLineWidth(t, s) {
		var v = s / t;
		//Vlist.push(v);
		var lw;

		if (v < 0.1)
			lw = 30;
		else
			lw = Math.ceil(20 / (v + 0.9) + 10);
		if (lastLineWidth == -1)
			return lw;
		else {
			lastLineWidth = lastLineWidth * 2 / 3 + lw / 3;
			return lastLineWidth;
		}
	}

	function drawRice() {
		ctx.strokeStyle = 'rgb(230,11,9)';
		ctx.beginPath();
		ctx.lineWidth = 6;
		ctx.strokeRect(3, 3, canvasWidth - 6, canvasHeight - 6);
		ctx.lineWidth = 1;
		ctx.save();
		ctx.translate(canvasWidth / 2, canvasHeight / 2);
		for (var i = 0; i < canvasWidth / 2; i += 30) {
			ctx.beginPath();
			ctx.moveTo(i, 0);
			ctx.lineTo(i + 20, 0);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(-i, 0);
			ctx.lineTo(-i - 20, 0);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(0, i);
			ctx.lineTo(0, i + 20);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(0, -i);
			ctx.lineTo(0, -i - 20);
			ctx.stroke();
		}
		ctx.restore();
		ctx.save();
		ctx.translate(canvasWidth / 2, canvasHeight / 2);
		ctx.rotate(PI / 4);
		for (var i = 0; i < canvasWidth / 2 * Math.pow(2, 1 / 2); i += 30) {
			ctx.beginPath();
			ctx.moveTo(i, 0);
			ctx.lineTo(i + 20, 0);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(-i, 0);
			ctx.lineTo(-i - 20, 0);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(0, i);
			ctx.lineTo(0, i + 20);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(0, -i);
			ctx.lineTo(0, -i - 20);
			ctx.stroke();
		}
		ctx.restore();
	}

	function Distance(ll, cl) {
		return Math.sqrt((ll.x - cl.x) * (ll.x - cl.x) + (ll.y - cl.y) * (ll.y - cl.y));
	}

	function windowToCanvas(x, y) {
		var cc = canvas.getBoundingClientRect();
		return {
			x: Math.round(x - cc.left),
			y: Math.round(y - cc.top)
		};
	}
</script>
</html>
